<?php
/**
 * This file is a part of XCRM Core Package
 *
 * @link      https://webwizardry.ru/projects/xcrm
 * @license   https://webwizardry.ru/projects/xcrm/license/
 * @copyright Copyright (c) 2020, Web Wizardry (http://webwizardry.ru)
 */

namespace XCrm\Data;
use XCrm\Database\Helper\TableDescriptionHelper;

class ActiveRecordConfigurable extends ActiveRecord
{
    use ModelTrait;

    protected $_referenceCache = [];

    public function __get($name)
    {
        if (isset($this->_referenceCache[$name])) return $this->_referenceCache[$name];

        $refAttribute = $this->app->referenceManager->referenceKeyPrefix . $name;
        if ($this->hasAttribute($refAttribute)) {
            if ($value = $this->$refAttribute) {
                $this->_referenceCache[$name] = $this->app->referenceManager->getReferenceObject($name, $value);
                return $this->_referenceCache[$name];
            }
            return null;
        }

        return parent::__get($name);
    }

    /**
     * Возвращает описание конфигурации таблицы БД, связанной с данной моделью
     * @param null|array $skipAttributes
     * @return TableDescriptionHelper
     */
    public static function getDescription($skipAttributes = null)
    {
        return static::getDb()->describeTable(static::tableName(), $skipAttributes);
    }

    /**
     * Проверяет наличие колонки с заданным именем в связанной таблице БД
     * @param string $name
     * @return bool
     */
    public static function hasTableColumn($name)
    {
        return static::getDescription()->hasTableColumn($name);
    }

    /**
     * Метод для внешних вызовов построителя запросов.
     * Создает объект построителя запросов в зависимости от типа модели и доролнительных условий.
     * @return ActiveQuery
     */
    public static function getFindAllQuery()
    {
        return static::isNestedSets()
            ? static::find()->orderBy(['tk_left' => SORT_ASC])
            : static::find();
    }

    /**
     * {@inheritDoc}
     */
    public static function find()
    {
        return static::isNestedSets()
            ? new ActiveQueryNestedSets(get_called_class())
            : new ActiveQuery(get_called_class());
    }

    /**
     * @return ActiveRecordConfigurable|string|null
     */
    public function getParentModelClass()
    {
        if (static::isNestedSets()) return $this;
        return static::hierarchy()['parent'] ?? null;
    }

    /**
     * Возвращает true, если модель связана с деревом вложенных множеств
     * @return bool
     */
    public static function isNestedSets()
    {
        return static::getDescription()->isNestedSets();
    }

    /**
     * Возвращает true, если к модели применима ручная сортировка записей
     * @return bool
     */
    public static function isSortable()
    {
        return static::getDescription()->isSortable();
    }

    public function behaviors()
    {
        return static::getDescription()->behaviors;
    }

    public function transactions()
    {
        return static::isNestedSets()
            ? [self::SCENARIO_DEFAULT => self::OP_ALL]
            : parent::transactions();
    }


    public function rules()
    {
        return static::getDescription()->rules;
    }

    public function load($data, $formName = null)
    {
        return parent::load($data, $formName); // TODO: Change the autogenerated stub
    }

    public function attributeLabels()
    {
        $l = static::getDescription()->getLabels();
        if (!empty($l)) {
            foreach ($l as $k=>$v) $l[$k] = static::t($v);
        }
        return $l;
    }

    public function hasAttributeName($name)
    {
        if (static::isNestedSets() && 'parent_id' === $name) return true;
        return parent::hasAttribute($name);
    }

    public static function findByUrl($url, $condition = [])
    {
        if (static::isNestedSets()) {
            if ('/' === $url || empty($url)) {
                return static::findOne(array_merge($condition, ['url' => '/']));
            } else {
                $parts = explode('/', $url);
                if (empty($parts[count($parts)-1])) {
                    unset($parts[count($parts)-1]);
                }

                $query = static::find();
                foreach ($parts as $k=>$v) {
                    $query->orWhere(['tk_depth' => $k + 1, 'url' => $v]);
                }
                $query->andWhere(['is_active' => 1]);
                $query->orderBy(['tk_depth' => SORT_DESC]);
                $query->limit(1);

                $page = $query->one();

                return $page;

            }
        } else {
            return null;
        }
    }
}